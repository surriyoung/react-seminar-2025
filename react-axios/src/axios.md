# Axios를 Fetch보다 선호하는 이유

- **간결하고 직관적인 문법**
  Axios는 요청과 응답 처리 과정이 간단하고 직관적으로 작성됩니다. `fetch`를 사용할 경우, 요청 시 다양한 옵션을 직접 구성해야 하고, 응답 데이터는 `.json()` 메서드를 호출해 수동으로 파싱해야 합니다.
- **자동 JSON 변환**
  Axios는 응답 데이터를 자동으로 JSON으로 변환해주기 때문에 `.json()`을 따로 호출할 필요가 없습니다.
- **요청 및 응답 인터셉터 지원**
  Axios는 요청 전/후를 가로채어 처리할 수 있는 인터셉터 기능을 제공해, 공통 헤더 설정, 토큰 관리, 에러 처리 등을 쉽게 구현할 수 있습니다.
- **타임아웃 설정 및 취소 기능**
  기본적으로 타임아웃 설정을 지원하며, 요청을 취소하는 기능도 포함되어 있어 네트워크 요청 제어에 유리합니다.
- **브라우저 호환성 및 에러 핸들링**
  Axios는 HTTP 에러 상태 코드(4xx, 5xx)에 대해 자동으로 `catch` 블록으로 전달하지만, fetch는 기본적으로 네트워크 오류가 아닐 경우 `.then()` 블록이 실행되므로 에러 핸들링에 주의가 필요합니다.

# Axios 설치방법

- yarn add axios
- npm install axios

# 📘 Q&A

## 📌 axios 요청 관련

### 왜 `finally`에서도 `setLoading(false)`를 호출하나요?

- `.then()`과 `.catch()` 양쪽 모두에 `setLoading(false)`를 넣었더라도,
  - **예상치 못한 흐름 변경이나 조건 분기** 시 안전하게 로딩을 꺼주는 역할입니다.

### `axios` 대신 `fetch()`를 쓰면 어떻게 되나요?

- `fetch()`는 내장 함수지만,
  - JSON 파싱을 수동으로 해야 하고,
  - 오류 핸들링이 더 복잡합니다.
- `axios`는 자동으로 JSON 변환, 간편한 에러 처리 등 **실무에서 더 선호**됩니다.

---

## 📌 상태 관리 (`useState`) 관련

### 여러 개의 `useState`를 나눠서 쓰는 이유는?

- 상태마다 분리하면
  - 렌더링 최적화가 쉬워지고,
  - 코드의 **의도와 책임이 명확**해집니다.

---

## 📌 비동기 처리 관련

### 비동기 요청 내부에서 동기적인 처리는 못 하나요?

- `.then()` 체인 또는 `async/await` 사용으로
  - 비동기 흐름을 동기적인 코드처럼 표현할 수 있습니다.

---

## 📌 렌더링 최적화 관련

### 왜 `key={user.id}`를 사용하나요?

- React가 리스트 아이템을 식별해 **효율적인 업데이트**를 하기 위해 꼭 필요합니다.
- `key`는 **고유한 값**이어야 합니다.

---

## 로딩 처리 관련

### 7. `loading` 상태는 꼭 필요하나요?

- 데이터가 없다는 것(`users.length === 0`)과
  - **아직 로딩 중**이라는 상태는 다릅니다.
- `loading` 플래그가 있으면 **명확한 상태 구분이 가능**합니다.

### 8. 로딩 중엔 텍스트 말고 스피너로 바꾸려면?

- 텍스트 대신 컴포넌트로 스피너를 넣을 수 있습니다.
- 예: `react-spinners`, `react-loader-spinner` 등 라이브러리 사용 가능.

---

## 기타 실무 관련

### 9. API 주소가 코드에 직접 써 있는데, 실무에서도 이렇게 하나요?

- 실무에서는 **`.env` 파일에 API 주소를 분리**해서 사용합니다.
- 환경에 따라 API를 다르게 설정할 수 있게 함.

---

### 10. `useEffect` 안 말고 밖에서 `axios` 호출하면 안 되나요?

- 함수 바깥에서 호출하면 **렌더링마다 반복 호출**되기 때문에,
- `useEffect`로 감싸고 빈 배열 `[]`을 줘야 **딱 한 번만 실행**됩니다.

---
